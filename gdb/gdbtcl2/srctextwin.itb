#
# SrcTextWin
# ----------------------------------------------------------------------
# Implements the paned text widget with the source code in in.
# This widget is typically embedded in a SrcWin widget.
#
# ----------------------------------------------------------------------
#   Copyright (C) 1997, 1998, 1999 Cygnus Solutions

# ------------------------------------------------------------------
#  CONSTRUCTOR - create new source text window
# ------------------------------------------------------------------
body SrcTextWin::constructor {args} {
  eval itk_initialize $args
  set top [winfo toplevel $itk_interior]
  if {$parent == {}} {
    set parent [winfo parent $itk_interior]
  }

  if {![info exists break_images(bp)]} {
    set size [font measure [pref get gdb/src/font] "W"]
    set break_images(bp)          [makeBreakDot $size \
				     [pref get gdb/src/bp_fg]]
    set break_images(temp_bp)     [makeBreakDot $size \
				     [pref get gdb/src/temp_bp_fg]]
    set break_images(disabled_bp) [makeBreakDot $size \
				     [pref get gdb/src/disabled_fg]]
    set break_images(tp)          [makeBreakDot $size \
				     [pref get gdb/src/trace_fg]]
    set break_images(thread_bp)   [makeBreakDot $size \
				     [pref get gdb/src/thread_fg]]
    set break_images(bp_and_tp)   [makeBreakDot $size \
				     [list [pref get gdb/src/trace_fg] \
					[pref get gdb/src/bp_fg]]] 
  }

  if {$ignore_var_balloons} {
    set UseVariableBalloons 0
  } else {
    set UseVariableBalloons [pref get gdb/src/variableBalloons]
  }
  
  set Linenums [pref get gdb/src/linenums]
  
  #Initialize state variables
  set pc(filename) ""
  set pc(func) ""
  set pc(line) 0
  set pc(addr) ""
  set pc(asm_line) 0
  set pc(lib) ""
  set current(filename) ""
  set current(funcname) ""
  set current(line) 0
  set current(addr) ""
  set current(asm_line) 0
  set current(tag) "BROWSE_TAG"
  set current(mode) "SOURCE"
  set current(lib) ""  

  build_popups  
  build_win
  
  # add hooks
  add_hook gdb_breakpoint_change_hook "$this bp"
  
  if {$Tracing} {
    add_hook control_mode_hook "$this set_control_mode"
    add_hook gdb_trace_find_hook "$this trace_find_hook"
  }
  
  if {$UseVariableBalloons} {
    add_hook gdb_idle_hook "$this updateBalloon"
  }
  global ${this}_balloon
  trace variable ${this}_balloon w "$this trace_help"

}

# ------------------------------------------------------------------
#  DESTRUCTOR - destroy window containing widget
# ------------------------------------------------------------------
body SrcTextWin::destructor {} {
  remove_hook gdb_breakpoint_change_hook "$this bp"
  remove_hook gdb_idle_hook "$this updateBalloon"
  if {$Tracing} {
    remove_hook control_mode_hook "$this set_control_mode"
  }
}

# ------------------------------------------------------------------
#  METHOD:  trace_find_hook - response to the tfind command.  All we
#  need to do here is to remove the trace tags, if we are exiting
#  trace mode
# ------------------------------------------------------------------
body SrcTextWin::trace_find_hook {mode from_tty} {
  if {[string compare $mode -1] == 0} {
    if {$Browsing} {
      $twin tag remove STACK_TAG 1.0 end
    }
  } 
}

# ------------------------------------------------------------------
#  METHOD:  set_control_mode- switches the src window between 
#           browsing -> mode = 1
#           controlling -> mode = 0
# ------------------------------------------------------------------
body SrcTextWin::set_control_mode {mode} {
  debug "Setting control mode of $twin to $mode"
  if {$mode} {
    set Browsing 1
  } else {
    set Browsing 0
  }
  
  switch $current(mode) {
    SOURCE {
      config_win $twin
    }
    ASSEMBLY {
      config_win $twin A
    }
    MIXED {
      config_win $twin M
    }
    SRC+ASM {
      config_win $twin
      config_win $bwin A
    }
  }      
  
}

# ------------------------------------------------------------------
#  METHOD:  build_popups - build the popups for the source window(s)
# ------------------------------------------------------------------
#
# The popups array holds the data for the breakpoint & tracepoint popup menus.
# The elements are:
# Menus:
#   break_rgn - the popup for clicking in a bare break region
#   bp        - the popup for clicking on a set breakpoint
#   tp        - the popup for clicking on a set tracepoint
#   bp_and_tp - the popup for clicking on the break_region when the
#               line contains both a bp & a tp
#   source    - the popup for clicking on the source region of the window
#
# State:
#    saved_y  - the y value of the mouse click that posted the popup
#    saved_win- the Tk window which recieved the posting click
# 
# Disable info:
#    run_disabled - a list of {menu entry} pairs for all the menus that
#                   should be disabled when you are not running
#    browse_disabled - a similar list for menus that should be disabled
#                      when you are browsing a trace expt.
#
body SrcTextWin::build_popups {} {
  
  set popups(bp) $itk_interior.bp_menu
  set popups(tp) $itk_interior.tp_menu
  set popups(bp_and_tp) $itk_interior.tp_bp_menu
  set popups(tp_browse) $itk_interior.tp_browse_menu
  set popups(break_rgn) $itk_interior.break_menu
  set popups(source) $itk_interior.src_menu
  
  # This is a scratch popup menu we use when we are not over a bp...
  if {![winfo exists $popups(source)]} {
    menu $popups(source) -tearoff 0
  }
  
  if {![winfo exists $popups(break_rgn)]} {
    # breakpoint popup menu
    # don't enable hardware or conditional breakpoints until they are tested
    menu $popups(break_rgn) -tearoff 0
    
    set bp_fg [pref get gdb/src/bp_fg]
    set tp_fg [pref get gdb/src/trace_fg]
    
    if {[pref get gdb/control_target]} {
      
      addPopup break_rgn "Continue to Here" "$this continue_to_here" \
	[pref get gdb/src/PC_TAG] 0 0
      $popups(break_rgn) add separator
      
      addPopup break_rgn "Set Breakpoint" "$this set_bp_at_line" $bp_fg 
      
      lappend popups(break_rgn-browse) 1
      lappend popups(break_rgn-control) 1
      
      addPopup break_rgn "Set Temporary Breakpoint" "$this set_bp_at_line T" \
	[pref get gdb/src/temp_bp_fg]
      
      addPopup break_rgn "Set Breakpoint on Thread(s)..." \
	"$this ask_thread_bp" [pref get gdb/src/thread_fg] 0 0
    }
    
    if {$Tracing} {
      $popups(break_rgn) add separator
      addPopup break_rgn "Set Tracepoint" "$this set_tp_at_line" $tp_fg
    }
    
  }
  
  if {![winfo exists $popups(bp)]} {
    # this popup is used when the line contains a set breakpoint
    menu $popups(bp) -tearoff 0
    
    if {!$Browsing && [pref get gdb/control_target]} {
      addPopup bp "Continue to Here" "$this continue_to_here" green 0 0
      $popups(bp) add separator    
    }
    
    addPopup bp "Delete Breakpoint" "$this remove_bp_at_line" $bp_fg 

    # Currently you cannot set a tracepoint and a breakpoint at the same line...
    #
    #       if {$Tracing} {
    # 	addPopup bp "Set Tracepoint" "$this set_tp_at_line" $tp_fg
    #       }
  }

  if {![winfo exists $popups(tp)]} {
    # This is the popup to use when the line contains a set tracepoint
    
    menu $popups(tp) -tearoff 0
    
    if {[pref get gdb/control_target]} {
      
      addPopup tp "Continue to Here" "$this continue_to_here" green 0 0
      #	$popups(tp) add separator    

      # Currently you cannot set a tracepoint and a breakpoint at the same line...
      #      
      # 	addPopup tp "Set Breakpoint" "$this set_bp_at_line" $bp_fg

      # 	addPopup tp "Set Temporary Breakpoint" "$this set_bp_at_line T" \
	# 	  [pref get gdb/src/temp_bp_fg]
      
      # 	addPopup tp "Set Breakpoint on Thread(s)..." \
	# 	  "$this ask_thread_bp" \
	# 	  [pref get gdb/src/thread_fg] 0 0
    }
    
    if {$Tracing} {
      $popups(tp) add separator
      addPopup tp "Modify Tracepoint" "$this set_tp_at_line" $tp_fg
      addPopup tp "Delete Tracepoint" "$this remove_tp_at_line" $tp_fg
    }
  }
  
  # This is not currently used, since you can't set a bp & a tp on the same line.
  # N.B. however, we don't exclude this on the command line, but...

  if {![winfo exists $popups(bp_and_tp)]} {
    
    # this popup is used when the line contains a set breakpoint & tracepoint
    menu $popups(bp_and_tp) -tearoff 0
    
    if {!$Browsing && [pref get gdb/control_target]} {
      addPopup bp_and_tp "Continue to Here" "$this continue_to_here" \
	green 0 0
      $popups(bp_and_tp) add separator    
    }
    
    addPopup bp_and_tp "Delete Breakpoint" "$this remove_bp_at_line" $bp_fg
    if {$Tracing} {
      addPopup bp_and_tp "Modify Tracepoint" "$this set_tp_at_line" $tp_fg
      addPopup bp_and_tp "Delete Tracepoint" \
	"$this remove_tp_at_line" $tp_fg
    }
  }
  
  if {![winfo exists $popups(tp_browse)]} {
    
    # this popup is on a tracepoint when browsing.
    
    menu $popups(tp_browse) -tearoff 0
    addPopup tp_browse "Next hit Here" "$this next_hit_at_line" \
      green
  }
  
}

# ------------------------------------------------------------------
#  METHOD:  build_win - build the main source paned window
# ------------------------------------------------------------------
body SrcTextWin::build_win {} {
  cyg::panedwindow $itk_interior.p -background white

  set _tpane pane$filenum
  incr filenum
  
  $itk_interior.p add $_tpane
  set pane1 [$itk_interior.p childsite $_tpane]
  set Stwc(gdbtk_scratch_widget) $_tpane

  set twinp [iwidgets::scrolledtext $pane1.st -textbackground white \
	       -hscrollmode dynamic -vscrollmode dynamic]
  set twin [$twinp component text]
  pack $twinp -fill both -expand yes
  pack $itk_interior.p -fill both -expand yes
  config_win $twin
}

# ------------------------------------------------------------------
#  METHOD:  SetRunningState - set state based on if GDB is running or not.
#  This disables the popup menus when GDB is not running yet.
# ------------------------------------------------------------------
body SrcTextWin::SetRunningState {state} {
  debug "$state"
  foreach elem $popups(run_disabled) {
    $popups([lindex $elem 0]) entryconfigure [lindex $elem 1] -state $state
  }
}

# ------------------------------------------------------------------
#  METHOD:  enable - enable or disable bindings and change cursor
# ------------------------------------------------------------------
body SrcTextWin::enable {on} {
  if {$on} {
    set Running 0
    set glyph ""
    set bnd ""
    set status normal
  } else {
    set Running 1
    set glyph watch
    set bnd "break"
    set status disabled
  }

  bind $twin <B1-Motion> $bnd
  bind $twin <Double-1> $bnd
  bind $twin <Triple-1> $bnd
  enable_disable_src_tags $twin $status
  if {$bwin != ""} {
    bind $bwin <B1-Motion> $bnd
    bind $bwin <Double-1> $bnd
    bind $bwin <Triple-1> $bnd
    enable_disable_src_tags $bwin $status
  }

  $twin configure -cursor $glyph
  if {$bwin != ""} {
    $bwin configure -cursor $glyph
  }
}

# ------------------------------------------------------------------
# PROC:  makeBreakDot - make the break dot for the screen
# ------------------------------------------------------------------
body SrcTextWin::makeBreakDot {size colorList {image {}}} {
  if {$size > 32} {
    set size 32
  } elseif {$size < 1} {
    set size 1
  }

  if {$image == ""} {
    set image [image create photo -width $size -height $size]
  } else {
    $image blank
    $image configure -width $size -height $size
  }

  if {[llength $colorList] == 1} { 
    set x1 1
    set x2 [expr {1 + $size}]
    set y1 1
    set y2 $x2
    $image put $colorList -to 1 1 $x2 $y2
  } else {
    set x1 1
    set x3 [expr {1 + $size}]
    set x2 [expr int((1 + $size)/2)]
    set y1 1
    set y2 $x3
    $image put [lindex $colorList 0] -to 1 1 $x2 $y2
    $image put [lindex $colorList 1] -to [expr $x2 + 1] 1 $x3 $y2
  }
  
  return $image
}

# ------------------------------------------------------------------
# METHOD: setTabs - set the tabs for the assembly/src windows
# ------------------------------------------------------------------
body SrcTextWin::setTabs {win {asm ""}} {
  set fsize [font measure src-font "W"]
  set tsize [pref get gdb/src/tab_size]
  set rest ""
  
  if {$asm != ""} {
    set first  [expr {$fsize * 12}]
    set second [expr {$fsize * 13}]
    set third  [expr {$fsize * 34}]
    for {set i 1} {$i < 8} {incr i} {
      lappend rest [expr {(34 + ($i * $tsize)) * $fsize}] left
    }
    set tablist [concat [list $first right $second left $third left] $rest]
  } else {
    # SOURCE window
    # The first tab right-justifies the line numbers and the second
    # tab is the left margin for the start on the source code.  The remaining
    # tabs should be regularly spaced depending on prefs.
    if {$Linenums} {
      set first  [expr {$fsize * 6}]	;# "- " plus 4 digit line number
      set second [expr {$fsize * 7}]	;# plus a space after the number 
      for {set i 1} {$i < 8} {incr i} {
	lappend rest [expr {(7 + ($i * $tsize)) * $fsize}] left
      }
      set tablist [concat [list $first right $second left] $rest]
    } else {
      set first  [expr {$fsize * 2}]
      for {set i 1} {$i < 8} {incr i} {
	lappend rest [expr {(2 + ($i * $tsize)) * $fsize}] left
      }
      set tablist [concat [list $first left] $rest]
    }
  }
  $win configure -tabs $tablist
}

body SrcTextWin::enable_disable_src_tags {win how} {

  switch $how {
    normal {
      set cur1 dot
      set cur2 xterm
    }
    disabled {
      set cur1 watch
      set cur2 $cur1
    }
    browse {
      set cur1 dot
      set cur2 xterm
    }
  }

  if {[string compare $how browse] == 0} {
    
    $win tag bind break_rgn_tag <Enter> { }
    $win tag bind break_rgn_tag <Leave> { }
    
    foreach type $bp_types {
      $win tag bind ${type}_tag <Enter> { }
      $win tag bind ${type}_tag <Motion> { }
      $win tag bind ${type}_tag <Leave> { }
    }

  } else {
    
    $win tag bind break_rgn_tag <Enter> "$win config -cursor $cur1"
    $win tag bind break_rgn_tag <Leave> "$win config -cursor $cur2"
    
    foreach type $bp_types {
      $win tag bind ${type}_tag <Enter> "$win config -cursor $cur1"
      $win tag bind ${type}_tag <Motion> "$this motion bp %W %x %y"
      $win tag bind ${type}_tag <Leave> \
	"$this cancelMotion;$win config -cursor $cur2"
    }
  }

  $win tag bind tp_tag <Enter> "$win config -cursor $cur1"
  $win tag bind tp_tag <Motion> "$this motion bp %W %x %y"
  $win tag bind tp_tag <Leave> "$this cancelMotion;$win config -cursor $cur2"
}

# ------------------------------------------------------------------
#  METHOD:  config_win - configure the source or assembly text window
# ------------------------------------------------------------------
body SrcTextWin::config_win {win {asm ""}} {
  debug "$win $asm Tracing=$Tracing Browsing=$Browsing"
  
  $win config -borderwidth 2 -insertwidth 0 -wrap none -bg white
  
  # font
  set font [pref get gdb/src/font]
  $win configure -font $font
  
  setTabs $win $asm
  
  # set up some tags.  should probably be done differently
  # !! change bg?
  
  $win tag configure break_rgn_tag -foreground [pref get gdb/src/break_fg]
  foreach type $bp_types {
    $win tag configure ${type}_tag -foreground [pref get gdb/src/break_fg]
  }
  $win tag configure tp_tag -foreground [pref get gdb/src/break_fg]
  $win tag configure source_tag2 -foreground [pref get gdb/src/source2_fg]
  $win tag configure PC_TAG -background [pref get gdb/src/PC_TAG]
  $win tag configure STACK_TAG -background [pref get gdb/src/STACK_TAG]
  $win tag configure BROWSE_TAG -background [pref get gdb/src/BROWSE_TAG]
  
  # search tag used to highlight searches
  foreach option [$win tag configure sel] {
    set op [lindex $option 0]
    set val [lindex $option 4]
    eval $win tag configure search $op $val
  }
  
  # bind mouse button 3 to the popup men
  $win tag bind source_tag <Button-3> "$this do_source_popup %X %Y %x %y"
  $win tag bind source_tag2 <Button-3> "$this do_source_popup %X %Y %x %y"
  
  # bind mouse button 3 to the popup menus
  if {!$Browsing} {
    
    $win tag bind break_rgn_tag <Button-3> \
      "$this do_tag_popup break_rgn %X %Y %y; break"
    foreach type $bp_types {
      $win tag bind ${type}_tag <Button-3> "$this do_tag_popup bp %X %Y %y; break"
    }
    $win tag bind tp_tag <Button-3> "$this do_tag_popup tp %X %Y %y; break"
    $win tag bind bp_and_tp_tag <Button-3> "$this do_tag_popup bp_and_tp %X %Y %y; break"
  } else {
    $win tag bind tp_tag <Button-3> "$this do_tag_popup tp_browse %X %Y %y; break"
    $win tag bind break_rgn_tag <Button-3> { }
    foreach type $bp_types {
      $win tag bind ${type}_tag <Button-3> { }
    }
    $win tag bind bp_and_tp_tag <Button-3> "$this do_tag_popup tp_browse %X %Y %y; break"
    
  }
  
  # Disable printing and cut and paste keys; makes the window readonly
  # We do this so we don't have to enable and disable the
  # text widget everytime we want to modify it.
  
  bind $win <Key> {if {"%A" != "{}"} {break}}
  bind $win <Delete> break
  bind $win <ButtonRelease-2> {break}
  
  # GDB key bindings
  # We need to explicitly ignore keys with the Alt modifier, since
  # otherwise they will interfere with selecting menus on Windows.
  
  if {!$Browsing && [pref get gdb/control_target]} {
    bind_plain_key $win c "$this do_key continue; break" 
    bind_plain_key $win r "$this do_key run; break"
    bind_plain_key $win f "$this do_key finish; break"
  } else {
    bind_plain_key $win n "$this do_key tfind_next; break"
    bind_plain_key $win p "$this do_key tfind_prev; break"
    bind_plain_key $win f "$this do_key tfind_start; break"
    bind_plain_key $win l "$this do_key tfind_line; break"
    bind_plain_key $win h "$this do_key tfind_tp; break"
  }
  bind_plain_key $win u "$this do_key up; break"
  bind_plain_key $win d "$this do_key down; break"
  bind_plain_key $win x "$this do_key quit; break"
  
  if {!$Browsing && [pref get gdb/control_target]} {
    if {$asm != ""} {
      bind_plain_key $win s "$this do_key stepi; break"
      bind_plain_key $win n "$this do_key nexti; break"
    } else {
      bind_plain_key $win s "$this do_key step; break"
      bind_plain_key $win n "$this do_key next; break"
    }
  }
  
  bind_plain_key $win Control-h "$this do_key thread_list; break"
  bind_plain_key $win Control-f "$this do_key browser; break"
  bind_plain_key $win Control-d "$this do_key download; break"
  bind_plain_key $win Control-p "$this do_key print"
  bind_plain_key $win Control-u "$this do_key debug; break"
  bind_plain_key $win Control-o [list $this do_key open]
  
  if {!$Browsing && [pref get gdb/control_target]} {
    # Ctrl+F5 is another accelerator for Run
    bind_plain_key $win Control-F5 "$this do_key run"
  }
  
  bind_plain_key $win Control-F11 "$this do_key debug"
  bind_plain_key $win Alt-v "$win yview scroll -1 pages"
  bind_plain_key $win Control-v [format {
    %s yview scroll 1 pages
    break
  } $win]
  
  # bind mouse button 1 to the breakpoint method or tracepoint, 
  # depending on the settings of the B1_behavior setting.  We don't
  # have to bind to bp_and_tp because that will fall through to either
  # the tp or the bp tag.  We have to put in the break so that we don't
  # both remove & reinsert a BP when we have both a tp & a bp on the same line.
  # If we are browsing, then disable Button-1
  
  if {!$Browsing} {
    if {[pref get gdb/B1_behavior]} {
      $win tag bind break_rgn_tag <Button-1> "$this set_bp_at_line N $win %y; break"
      foreach type $bp_types {
	$win tag bind ${type}_tag <Button-1> "$this remove_bp_at_line $win %y; break"
      }
      $win tag bind tp_tag    <Button-1> "$this set_bp_at_line N $win %y; break"
    } else {
      $win tag bind break_rgn_tag <Button-1> "$this set_tp_at_line $win %y; break"
      foreach type $bp_types {
	$win tag bind ${type}_tag <Button-1> "$this set_tp_at_line $win %y; break"
      }
      $win tag bind tp_tag    <Button-1> "$this set_tp_at_line $win %y; break"
    }
  } else {
    $win tag bind break_rgn_tag <Button-1> { }
    foreach type $bp_types {
      $win tag bind ${type}_tag <Button-1> { }
    }
    $win tag bind tp_tag    <Button-1> { }      
  }
  
  
  # avoid special handling of double and triple clicks in break area
  bind $win <Double-1> [format {
    if {[lsearch [%s tag names @%%x,%%y] break_rgn_tag] >= 0} {
      break
    }
  } $win $win]
  bind $win <Triple-1> [format {
    if {[lsearch [%s tag names @%%x,%%y] break_rgn_tag] >= 0} {
      break
    }
  } $win $win]
  
  # bind window shortcuts
  bind_plain_key $win Control-s "$this do_key stack"
  bind_plain_key $win Control-r "$this do_key registers"
  bind_plain_key $win Control-m "$this do_key memory"
  bind_plain_key $win Control-w "$this do_key watch"
  bind_plain_key $win Control-l "$this do_key locals"
  #start-sanitize-kod
  bind_plain_key $win Control-k "$this do_key kod"
  #end-sanitize-kod
  if { !$Tracing } {
    bind_plain_key $win Control-b "$this do_key breakpoints"
  } else {
    bind_plain_key $win Control-t "$this do_key tracepoints"
    bind_plain_key $win Control-u "$this do_key tdump"
  }
  bind_plain_key $win Control-n "$this do_key console"
  
  if {$Browsing} {
    enable_disable_src_tags $win browse
  } else {
    enable_disable_src_tags $win normal
  }      
  
  if {$UseVariableBalloons} {
    $win tag bind source_tag <Motion> "$this motion var %W %x %y"
    $win tag bind source_tag <Leave> "$this cancelMotion"
  }
  
  # Up/Down arrow key bindings
  bind_plain_key $win Up [list %W yview scroll -1 units]
  bind_plain_key $win Down [list %W yview scroll +1 units]
}

# ------------------------------------------------------------------
#  METHOD:  addPopup - adds a popup to one of the source popup menus
# ------------------------------------------------------------------
body SrcTextWin::addPopup {menu label command {abg {}} {browse 1} {run 1}} {
  
  if {$abg == ""} {
    $popups($menu) add command -label $label -command $command 
  } else {
    $popups($menu) add command -label $label -command $command \
      -activebackground $abg
  }
  
  set index [$popups($menu) index last]
  if {!$run} {
    lappend popups(run_disabled) [list $menu $index]
  }
  if {!$browse} {
    lappend popups(browse_disabled) [list $menu $index]
  }
  
}

# ------------------------------------------------------------------
#  METHOD:  reconfig - used when preferences change
# ------------------------------------------------------------------
body SrcTextWin::reconfig {} {
  debug
  
  # Make sure we redo the break images when we reconfigure
  set size [font measure src-font "W"]
  makeBreakDot $size [pref get gdb/src/bp_fg] $break_images(bp)
  makeBreakDot $size [pref get gdb/src/temp_bp_fg] $break_images(temp_bp)
  makeBreakDot $size [pref get gdb/src/disabled_fg] $break_images(disabled_bp)
  makeBreakDot $size [pref get gdb/src/trace_fg] $break_images(tp)
  makeBreakDot $size \
    [list [pref get gdb/src/trace_fg] [pref get gdb/src/bp_fg]] \
    $break_images(bp_and_tp)
  makeBreakDot $size [pref get gdb/src/thread_fg] $break_images(thread_bp)

  # Tags
  $twin tag configure PC_TAG -background [pref get gdb/src/PC_TAG]
  $twin tag configure STACK_TAG -background [pref get gdb/src/STACK_TAG]
  $twin tag configure BROWSE_TAG -background [pref get gdb/src/BROWSE_TAG]
  setTabs $twin
  
  # Variable Balloons
  if {$ignore_var_balloons} {
    set balloons 0
  } else {
    set balloons [pref get gdb/src/variableBalloons]
  }
  if {$UseVariableBalloons != $balloons} {
    set UseVariableBalloons $balloons
    if {$UseVariableBalloons} {
      $twin tag bind source_tag <Motion> "$this motion var %W %x %y"
      $twin tag bind source_tag <Leave> "$this cancelMotion"
      add_hook gdb_idle_hook [list $this updateBalloon]
    } else {
      cancelMotion
      $twin tag bind source_tag <Motion> {}
      $twin tag bind source_tag <Leave> {}
      $twin tag remove _show_variable 1.0 end 
      remove_hook gdb_idle_hook [list $this updateBalloon]
    }
  }

  # Tracing Hooks
  catch {remove_hook control_mode_hook "$this set_control_mode"}
  catch {remove_hook gdb_trace_find_hook "$this trace_find_hook"}
  if {$Tracing} {
    add_hook control_mode_hook "$this set_control_mode"
    add_hook gdb_trace_find_hook "$this trace_find_hook"
  }

  # Popup colors

  # need to rewrite because of the new addPopup function
  #    if {$Tracing} {
  #      $twin.bmenu entryconfigure 0 -activebackground [pref get gdb/src/trace_fg]
  #    } else {
  #      $twin.bmenu entryconfigure 0 -activebackground [pref get gdb/src/PC_TAG]
  #      $twin.bmenu entryconfigure 1 -activebackground [pref get gdb/src/bp_fg]
  #      $twin.bmenu entryconfigure 2 -activebackground \
    #	[pref get gdb/src/temp_bp_fg]
  #     $twin.bmenu entryconfigure 3 -activebackground \
    #	[pref get gdb/src/thread_fg]
  #    }
}

# ------------------------------------------------------------------
# METHOD: updateBalloon - we have gone idle, update the balloon
# ------------------------------------------------------------------
body SrcTextWin::updateBalloon {} {

    set err [catch {$_balloon_var valueChanged} changed]
    catch {$_balloon_var name} var

    if {!$err} {
      if {$changed != "VARIABLE_UNCHANGED"} {
	# The variable's value has changed, so update the
	# balloon with its new value
	balloon register $twin "$var=[balloon_value $_balloon_var]" _show_variable
      }
    }
  }

body SrcTextWin::balloon_value {variable} {

  catch {$variable value} value
  set value [string trim $value \ \r\t\n]

  # Insert the variable's type for things like ptrs, etc.
  catch {$variable type} type 
  if {$value == "{...}"} {
    set val "$type $value"
  } elseif {[regexp -- {0x([0-9a-fA-F]+) <[a-zA-Z_].*} $value str]} {
    set val $str
  } elseif {[string first * $type] != -1} {
    set val "($type) $value"
  } elseif {[string first \[ $type] != -1} {
    set val "$type"
  } else {
    set val "$value"
  }

  return $val
}

# ------------------------------------------------------------------
# METHOD: ClearTags - clear all tags
# ------------------------------------------------------------------
body SrcTextWin::ClearTags {} {
  foreach tag {PC_TAG BROWSE_TAG STACK_TAG} {
    $twin tag remove $tag $current(line).2 $current(line).end
    $twin tag remove $tag $pc(line).2 $pc(line).end
    $twin tag remove $tag $current(asm_line).2 $current(asm_line).end
    if {$bwin != ""} {
      $bwin tag remove $tag $current(asm_line).2 $current(asm_line).end
    }
  }
}

# ------------------------------------------------------------------
# METHOD: FillSource - fill a window with source
# ------------------------------------------------------------------
body SrcTextWin::FillSource {w tagname filename funcname line addr pc_addr lib} {
  global gdb_running
  upvar ${w}win win

  debug "$gdb_running $tagname line=$line pc(line)=$pc(line)"
  debug "current(filename)=$current(filename) filename=$filename"

  if {$filename != ""} {
    # load new file if necessary
    if {[string compare $filename $current(filename)] != 0 \
	  || $mode_changed} {	
      if {![LoadFile $w $filename $lib]} {
	# failed to find source file
	dbug W "Changing to ASSEMBLY"
	set current(line) $line
	set current(tag) $tagname
	set current(addr) $addr
	set current(funcname) $funcname
	set current(filename) $filename
	set current(lib) $lib
	set oldmode SOURCE
	$parent mode "" ASSEMBLY
	return
      }
      if {$current(mode) != "SRC+ASM"} {
	# reset this flag in FillAssembly for SRC+ASM mode
	set mode_changed 0
      }
    }

    debug "cf=$current(filename) pc=$pc(filename) filename=$filename"
    if {$current(filename) != ""} {
      if {$gdb_running && $pc(filename) == $filename} {
	# set the PC tag in this file
	$win tag add PC_TAG $pc(line).2 $pc(line).end
      }
      if {$tagname != "PC_TAG"} {
	if {$gdb_running && ($pc(filename) == $filename) \
	      && ($pc(line) == $line)} {
	  # if the tag is on the same line as the PC, set a PC tag
	  $win tag add PC_TAG $line.2 $line.end
	} else {
	  $win tag add $tagname $line.2 $line.end
	}
      }
      if {$pc(filename) == $filename && $line == 0} {
	# no line specified, so show line with PC
	display_line $win $pc(line)
      } else {
	display_line $win $line
      }
    }
    return
  }
  # no source; switch to assembly
  debug "no source file; switch to assembly"
  set current(line) $line
  set current(tag) $tagname
  set current(addr) $addr
  set current(funcname) $funcname
  set current(filename) $filename
  set current(lib) $lib
  set oldmode $current(mode)
  $parent mode "" ASSEMBLY
}

# ------------------------------------------------------------------
# METHOD: FillAssembly - fill a window with disassembled code
# ------------------------------------------------------------------
body SrcTextWin::FillAssembly {w tagname filename funcname line addr pc_addr lib} {
  global gdb_running
  upvar ${w}win win
  upvar _${w}pane pane
  debug "$win $tagname $filename $funcname $line $addr $pc_addr"
  debug "mode_changed=$mode_changed"
  debug "funcname=$funcname"
  debug "current(funcname)=$current(funcname)"
  if {$funcname == ""} {
    set oldpane $pane
    set pane $Stwc(gdbtk_scratch_widget)
    set win [[$itk_interior.p childsite $pane].st component text]
    $win delete 0.0 end
    $win insert 0.0 "Select function name to disassemble"
    if {$oldpane != "" && $oldpane != $pane} {
      $itk_interior.p replace $oldpane $pane
    } else {
      $itk_interior.p show $pane
    }
    return
  } elseif {$funcname != $current(funcname) || $mode_changed} {
    set mode_changed 0
    set oldpane $pane
    if {[LoadFromCache $w $addr A $lib]} {
      debug [format "Disassembling at %x" $addr]
      debug "cf=$current(filename) name=$filename"
      if {[catch {gdb_disassemble nosource $addr} dis]} {
	# print some intelligent error message?
	dbug E "Disassemble failed: $dis"
	UnLoadFromCache $w $oldpane $addr A $lib
	set pane $Stwc(gdbtk_scratch_widget)
	set win [[$itk_interior.p childsite $pane].st component text]
	$win delete 0.0 end
	$win insert 0.0 "Unable to Read Instructions at $addr"
	if {$oldpane != "" && $oldpane != $pane} {
	  $itk_interior.p replace $oldpane $pane
	} else {
	  $itk_interior.p show $pane
	}
      } else {
	# fill in new text widget
	set i 1
	foreach line [split $dis \n] {
	  if {[string index $line 0] != " "} {
	    set address [lindex [split $line] 4]
	    if {$i == 1} {set asm_lo_addr $address}
	    # Source line
	    regexp {([0-9]*)[ ]*(.*)} $line match srcline srccode
	    if {$srcline != ""} {
	      $win insert $i.end "\t$srcline"
	      $win insert $i.end "\t$srccode\n" source_tag
	      set _map($Cname,srcline=$srcline) $i
	    }
	  } else {
	    # assembly line
	    set address [lindex [split $line] 4]
	    if {$i == 1} {set asm_lo_addr $address}
	    set line [split [string trim $line]]
	    set lineNum [lindex $line 0]
	    set offset  [lindex $line 1]
	    set code [join [lrange $line 2 end]]
	    #debug "lineNum = $lineNum\noffset = $offset\n code=$code\n"
	    $win insert $i.0 "-\t$lineNum\t$offset\t$code\n"
	    $win tag add break_rgn_tag $i.0 $i.11
	    $win tag add source_tag $i.12 $i.end
	    set asm_hi_addr $address
	    set _map($Cname,pc=$address) $i
	    set _map($Cname,line=$i) $address
	  }
	  incr i
	}
      }
    }
    set current(filename) $filename
    set do_display_breaks 1
  }
  
  # highlight proper line number
  if {[info exists _map($Cname,pc=$addr)]} {
    # if current file has PC, highlight that too
    if {$gdb_running && $tagname != "PC_TAG" && $pc(filename) == $filename
	&& $pc(func) == $funcname} {
      set pc(asm_line) $_map($Cname,pc=$pc_addr)
      $win tag add PC_TAG $pc(asm_line).2 $pc(asm_line).end
    }
    set current(asm_line) $_map($Cname,pc=$addr)
    # don't set browse tag if it is at PC
    if {$pc_addr != $addr || $tagname == "PC_TAG"} {
      # HACK.  In STACK mode we usually want the previous instruction
      # but not when we are browsing a trace experiment.
      if {[string compare $tagname "STACK_TAG"] == 0 && !$Browsing} {
	incr current(asm_line) -1
      }
      $win tag add $tagname $current(asm_line).2 $current(asm_line).end
    }
  }
  display_line $win $current(asm_line)
}


# ------------------------------------------------------------------
# METHOD: FillMixed - fill a window with mixed source and assembly
# ------------------------------------------------------------------
body SrcTextWin::FillMixed {w tagname filename funcname line addr pc_addr lib} {
  global gdb_running
  upvar ${w}win win
  upvar _${w}pane pane
  debug "$win $tagname $filename $funcname $line $addr $pc_addr"  

  set asm_lo_addr ""
  
  if {$funcname == ""} {
    set oldpane $pane
    set pane $Stwc(gdbtk_scratch_widget)
    set win [[$itk_interior.p childsite $pane].st component text]
    $win delete 0.0 end
    $win insert 0.0 "Select function name to disassemble"
    if {$oldpane != ""} {
      $itk_interior.p replace $oldpane $pane
    } else {
      $itk_interior.p show $pane
    }
  } elseif {$funcname != $current(funcname) || $mode_changed} {
    set mode_changed 0
    set oldpane $pane
    if {[LoadFromCache $w $funcname M $lib]} {
      debug [format "Disassembling at %x" $addr]
      if {[catch {set dis [gdb_disassemble source $addr]} mess] } {
	# print some intelligent error message
	dbug W "Disassemble Failed: $mess"
	UnLoadFromCache $w $oldpane $funcname M $lib
	set current(line) $line
	set current(tag) $tagname
	set current(addr) $addr
	set current(funcname) $funcname
	set current(filename) $filename
	set current(lib) $lib
	set oldmode MIXED
	$parent mode "" ASSEMBLY
	return
      } else {
	# Due to the bizarre and perverted ways that output gets
	# written into buffers that eventually get captured and
	# passed back to tcl, if the source file can not be read
	# an error message will be in the first line and the following
	# lines will just say "in filename.c".  We could disallow
	# this entirely, but it may actually be useful to see where
	# the source lines are in the assembly code, even if they
	# are not displayed.
	
	# fill in new widget
	set i 1
	foreach line [split $dis \n] {
	  if {[string index $line 0] != " "} {
	    # Source line
	    regexp {([0-9]*)[ ]*(.*)} $line match srcline srccode
	    if {$srcline != ""} {
	      $win insert $i.end "\t$srcline"
	      $win insert $i.end "$srccode\n" source_tag2
	      set _map($Cname,srcline=$srcline) $i
	    }
	  } else {
	    # Assembly line
	    set address [lindex [split $line] 4]
	    if {$asm_lo_addr == ""} {set asm_lo_addr $address}
	    set line [split [string trim $line]]
	    set lineNum [lindex $line 0]
	    set offset  [lindex $line 1]
	    set code [join [lrange $line 2 end]]
	    #debug "lineNum = $lineNum\noffset = $offset\n code=$code\n"
	    $win insert $i.0 "-\t$lineNum\t$offset\t$code\n"
	    $win tag add break_rgn_tag $i.0 $i.11
	    $win tag add source_tag $i.12 $i.end
	    set asm_hi_addr $address
	    set _map($Cname,pc=$address) $i
	    set _map($Cname,line=$i) $address
	  }
	  incr i
	}
      }
    }
    set current(filename) $filename
    # now set the breakpoints
    set do_display_breaks 1
  }
  # highlight proper line number
  if {[info exists _map($Cname,pc=$addr)]} {
    # if current file has PC, highlight that too
    if {$gdb_running && $tagname != "PC_TAG" && $pc(filename) == $filename
	&& $pc(func) == $funcname} {
      set pc(asm_line) $_map($Cname,pc=$pc_addr)
      $win tag add PC_TAG $pc(asm_line).2 $pc(asm_line).end
    }
    set current(asm_line) $_map($Cname,pc=$addr)
    debug "current(asm_line) = $current(asm_line)"
    if {$pc_addr != $addr || $tagname == "PC_TAG"} {
      # HACK.  In STACK mode we usually want the previous instruction
      if {$tagname == "STACK_TAG"} {
	incr current(asm_line) -1
      }
      $win tag add $tagname $current(asm_line).2 $current(asm_line).end
    }
  }
  display_line $win $current(asm_line)
}

# ------------------------------------------------------------------
# METHOD: location - display a location in a file
# ------------------------------------------------------------------
body SrcTextWin::location {tagname filename funcname line addr pc_addr lib} {
  debug "$tagname $filename $line $addr $pc_addr,  mode=$current(mode) oldmode=$oldmode  cf=$current(filename) lib=$lib"
  
  ClearTags
  
  if {$tagname == "PC_TAG" && $addr == $pc_addr} {
    set pc(filename) $filename
    set pc(line) $line
    set pc(addr) $addr
    set pc(func) $funcname
    set pc(lib)  $lib
  }
  
  if {$oldmode != "" && $filename != $current(filename)} {
    if {[gdb_find_file $filename] != ""} {
      set tmp $oldmode
      set oldmode ""
      $parent mode "" $tmp 0
    }
  }
  
  switch $current(mode) {
    SOURCE {
      FillSource t $tagname $filename $funcname $line $addr $pc_addr $lib
    }
    ASSEMBLY {
      FillAssembly t $tagname $filename $funcname $line $addr $pc_addr $lib
    }
    MIXED {
      FillMixed t $tagname $filename $funcname $line $addr $pc_addr $lib
    }
    SRC+ASM {
      FillSource t $tagname $filename $funcname $line $addr $pc_addr $lib
      # This may seem redundant, but it is NOT.  FillSource can change
      # the mode from SOURCE to ASSEMBLY if sources were not found. If
      # this happens, then MIXED mode is pointless, so forget the bottom
      # pane.
      if {$current(mode) == "SRC+ASM"} {
	FillAssembly b $tagname $filename $funcname $line $addr $pc_addr $lib
      }
    }
  }
  set current(line) $line
  set current(tag) $tagname
  set current(addr) $addr
  set current(funcname) $funcname
  set current(filename) $filename
  set current(lib) $lib
  if {$do_display_breaks} {
    display_breaks
    set do_display_breaks 0
  }
}

# ------------------------------------------------------------------
#  METHOD:  LoadFile - loads in a new source file
# ------------------------------------------------------------------
body SrcTextWin::LoadFile {w name lib} {
  debug "$name $current(filename) $current(mode)"
  upvar ${w}win win
  upvar _${w}pane pane
  
  set oldpane $pane
  if {[LoadFromCache $w $name "" $lib]} {
    debug "READING $name"
    if {[catch {gdb_loadfile $win $name $Linenums} msg]} {
      dbug W "Error opening $name:  $msg"
      #if {$msg != ""} {
      #  tk_messageBox -icon error -title "GDB" -type ok \
	#    -modal task -message $msg
      #}
      UnLoadFromCache $w $oldpane $name "" $lib
      return 0
    }
  }
  set current(filename) $name
  # Display all breaks/traces
  set do_display_breaks 1
  return 1
}

# ------------------------------------------------------------------
#  METHOD:  display_line - make sure a line is displayed and near the center
# ------------------------------------------------------------------

body SrcTextWin::display_line { win line } {
  ::update idletasks
  # keep line near center of display
  set pixHeight [winfo height $win]
  set topLine [lindex [split [$win index @0,0] .] 0]
  set botLine [lindex [split [$win index @0,${pixHeight}] .] 0]    
  set margin [expr {int(0.2*($botLine - $topLine))}]
  if {$line < [expr {$topLine + $margin}]} {
    set num [expr {($topLine - $botLine) / 2}]
  } elseif {$line > [expr {$botLine - $margin}]} {
    set num [expr {($botLine - $topLine) / 2}]
  } else {
    set num 0
  }
  $win yview scroll $num units
  $win see $line.0
}

# ------------------------------------------------------------------
# METHOD: display_breaks - insert all breakpoints and tracepoints
# uses current(filename) in SOURCE mode
# ------------------------------------------------------------------

body SrcTextWin::display_breaks {} {
  debug
  
  # clear any previous breakpoints
  foreach type "$bp_types tp" {
    foreach {start stop} [$twin tag ranges ${type}_tag] {
      scan $start "%d." linenum
      removeBreakTag $twin $linenum ${type}_tag
    }
  }
  
  # now do second pane if it exists
  if {[info exists bwin]} {
    foreach type "$bp_types tp" {
      foreach {start stop} [$twin tag ranges ${type}_tag] {
	scan $start "%d." linenum
	removeBreakTag $twin $linenum ${type}_tag
      }
    }
  }
  
  # Display any existing breakpoints.
  foreach bpnum [gdb_get_breakpoint_list] {
    set info [gdb_get_breakpoint_info $bpnum]
    set addr [lindex $info 3]
    set line [lindex $info 2]
    set file [lindex $info 0]
    set type [lindex $info 6]
    set enabled [lindex $info 5]
    bp create $bpnum $addr $line $file $type $enabled
  }
  # Display any existing tracepoints.
  foreach bpnum [gdb_get_tracepoint_list] {
    set info [gdb_get_tracepoint_info $bpnum]
    set addr [lindex $info 3]
    set line [lindex $info 2]
    set file [lindex $info 0]
    bp create $bpnum $addr $line $file tracepoint
  }
}

# ------------------------------------------------------------------
# METHOD: insertBreakTag - insert the right amount of tag chars
#         into the text window WIN, at line linenum.
# ------------------------------------------------------------------
body SrcTextWin::insertBreakTag {win linenum tag} {
  debug "$win $linenum $tag"
  
  # Get the tags at the current line.  
  
  # If there is a "break_rgn_tag", then there are currently no other
  # break/trace points at this line.  So replace the break_rgn_tag
  # with this tag.  Otherwise, add the new tag, and then the joint
  # tag.  We will query the length of the previous tag, so we don't have
  # to hard code it here.
  
  set tag_list [$win tag names $linenum.0]
  set img_name [string range $tag 0 [expr [string length $tag] - 5]]
  
  if {[lsearch $tag_list break_rgn_tag] != -1} {
    set stop [lindex [$win tag nextrange break_rgn_tag \
			$linenum.0 "$linenum.0 lineend"] 1]
    $win tag remove break_rgn_tag $linenum.0 "$linenum.0 lineend"
    $win delete $linenum.0
    
    # Strip the "_tag" off the end of the tag to get the image name.
    $win image create $linenum.0 -image $break_images($img_name)
    $win tag add $tag $linenum.0 $stop
  } else {
    
    set other_tag [lindex $tag_list \
		     [lsearch -glob $tag_list {*[bt]p_tag}]]
    if {$other_tag == ""} {
      set stop 4
    } else {
      set stop [lindex [$win tag nextrange $other_tag \
			  $linenum.0 "$linenum.0 lineend"] 1]
    }

    $win tag add $tag $linenum.0 $stop
    $win image configure $linenum.0 -image $break_images($img_name)

  }
}

# ------------------------------------------------------------------
# METHOD: removeBreakTag - remove a break tag (breakpoint or tracepoint)
#         from the given line.  If this is the last break tag on the 
#         line reinstall the break_rgn_tag
# ------------------------------------------------------------------
body SrcTextWin::removeBreakTag {win linenum tag } {
  debug "$win $linenum $tag"

  set tag_list [$win tag names $linenum.0]

  if {[set pos [lsearch -exact $tag_list $tag]] == -1} {
    debug "Tried to remove non-existant tag $tag"
    return
  } else {
    set tag_list [lreplace $tag_list $pos $pos]
  }

  # Use the range of the removed tag for any insertions, so we don't
  # have to hard code it here.

  set stop [lindex [$win tag nextrange $tag \
		      $linenum.0 "$linenum.0 lineend"] 1]

  $win tag remove $tag $linenum.0 "$linenum.0 lineend"

  # Now check what other tags are on this line.  If there are both bp & tp
  # tags, also remove the joint tag, otherwise install the break_rgn_tag.

  switch -glob $tag {
    *bp_tag {
      set only_one_tag [expr [set next_tag_index \
				[lsearch -glob $tag_list tp_tag]] == -1]
    }
    tp_tag {
      # Got to find out what kind of tag is here...
      set only_one_tag [expr [set next_tag_index \
				[lsearch -glob $tag_list *bp_tag]] == -1]
    }
  }

  if {$only_one_tag} {
    catch {$win image configure $linenum.0 -image {}}
    $win delete $linenum.0
    $win insert $linenum.0 "-"
    $win tag add break_rgn_tag $linenum.0 $stop
  } else {
    set other_tag [lindex $tag_list $next_tag_index]
    set img_name [string range $other_tag 0 \
		    [expr [string length $other_tag] - 5]]
    $win image configure $linenum.0 -image $break_images($img_name)
    $win tag remove bp_and_tp_tag $linenum.0 "$linenum.0 lineend"
  }
}

# ------------------------------------------------------------------
#  METHOD:  bp - set and remove breakpoints
#
#  if $addr is valid, the breakpoint will be set in the assembly or 
#  mixed window at that address.  If $line and $file are valid, 
#  a breakpoint will be set in the source window if appropriate.
# ------------------------------------------------------------------
body SrcTextWin::bp {action bpnum addr {linenum {}} {file {}} {type 0} {enabled 0}  {thread -1}} {
  debug "$action addr=$addr line=$linenum file=$file type=$type current(filename)=$current(filename)"
  
  switch $current(mode) {
    SOURCE {
      if {[string compare $file $current(filename)] == 0 && $linenum != {}} {
	do_bp $twin $action $linenum $type $bpnum $enabled $thread 0
      }
    }

    SRC+ASM {
      if {$addr != {} && [info exists _map($Cname,pc=$addr)]} {
	do_bp $bwin $action $_map($Cname,pc=$addr) $type $bpnum \
	  $enabled $thread 1
      }
      if {[string compare $file $current(filename)] == 0 && $linenum != {}} {
	do_bp $twin $action $linenum $type $bpnum $enabled $thread 0
      }
    }

    ASSEMBLY {
      if {$addr != {} &&[info exists _map($Cname,pc=$addr)]} {
	do_bp $twin $action $_map($Cname,pc=$addr) $type $bpnum \
	  $enabled $thread 1
      }
    }

    MIXED {
      if {$addr != {} && [info exists _map($Cname,pc=$addr)]} {
	do_bp $twin $action $_map($Cname,pc=$addr) $type $bpnum \
	  $enabled $thread 1
      }
    }
  }
}

# ------------------------------------------------------------------
#  METHOD:  do_bp - bp helper function
# ------------------------------------------------------------------
body SrcTextWin::do_bp { win action linenum type bpnum enabled thread asm} {
  debug "$action line=$linenum type=$type bpnum=$bpnum enabled=$enabled thread=$thread"
  
  if {$dont_change_appearance} {
    return
  }

  if {!$asm && $action == "delete" && [string compare $type tracepoint] != 0} {
    # make sure there are no more breakpoints on
    # this line.
    set bps [gdb_find_bp_at_line $current(filename) $linenum]
    if {[llength $bps] > 0} {
      foreach b $bps {
	if {$b != $bpnum} {
	  # OK we found another BP on this line.
	  # So we really just want to modify whats
	  # displayed on the line instead of deleting it.
	  # Also, for lack of a better solution, we will
	  # just display an image corresponding to the
	  # first found BP.  If you have a temporary and
	  # a perm BP on the same line, the image for the one 
	  # with the lower bpnum will be displayed.
	  set inf [gdb_get_breakpoint_info $b]
	  set action "modify"
	  set type [lindex $inf 6]
	  set bpnum $b
	  break
	}
      }
    }
  }

  if {[string compare $type "tracepoint"] == 0} {
    if {[string compare $action "delete"] != 0
	&& [lindex [gdb_get_tracepoint_info $bpnum] 4] == 0} {
      set type disabled_tracepoint
    }
  } else {
    if {$enabled == "0" } {
      set type disabled_bp
    } elseif {$thread != "-1"} {
      set type thread
    }
  }
  
  switch $type {
    donttouch {
      set tag_type bp_tag
    }
    delete {
      set tag_type temp_bp_tag
    }
    disabled_bp {
      set tag_type disabled_bp_tag
    }
    tracepoint {
      set tag_type tp_tag
    }
    disabled_tracepoint {
      set tag_type disabled_tp_tag
    }
    thread {
      set tag_type thread_bp_tag
    }
    default {
      dbug E "UNKNOWN BP TYPE $action $type"
      $win insert $linenum.0 "X" bp_tag
      set tag_type bp_tag
    }
  }
  
  if {[string compare $action "delete"] == 0} {
    removeBreakTag $win $linenum $tag_type
  } else {
    if {[string compare $action "modify"] == 0} {
      removeBreakTag $win $linenum $tag_type
    }
    insertBreakTag $win $linenum $tag_type
  }
}


# ------------------------------------------------------------------
#  METHOD:  hasBP - see if a line number has a breakpoint set
# ------------------------------------------------------------------
body SrcTextWin::hasBP {win line} {
  if {$win == ""} {
    set win $popups(saved_win)
  }

  if {[lsearch -glob [$win tag names $line.0] *bp_tag] >= 0} {
    return 1
  }
  return 0
}

# ------------------------------------------------------------------
#  METHOD:  hasTP - see if a line number has a tracepoint set
# ------------------------------------------------------------------
body SrcTextWin::hasTP {win line} {
  if {$win == ""} {
    set win $popups(saved_win)
  }

  if {[lsearch -exact [$win tag names $line.0] tp_tag] == 1} {
    return 1
  }
  return 0
}

# ------------------------------------------------------------------
#  METHOD:  report_current_location  
#    
#    This function reports the "current" location in the source
#    window, where current means what gdb_loc would return, if 
#    that point is actually visible in the window, or the middle
#    of the current window, if that point is not visible.
#
#  Return:
#    The gdb_loc result for the location found
# ------------------------------------------------------------------
body SrcTextWin::report_source_location {} {
  
  if {$current(filename) == ""} {
    error "No source file in window"
  }

  # Figure out if the return from gdb_loc is visible.

  set not_visible 1
  if {![catch {gdb_loc} loc_info]} {
    set loc_long_name [lindex $loc_info 2]
    set loc_line [lindex $loc_info 3]
    debug "Got loc_info: \"$loc_info\" and filename $current(filename) long_name: $loc_long_name"
    if {[string compare $current(filename) $loc_long_name] != 0} {
      set not_visible 1
    } else {
      foreach {name line} [lookup_line $twin 1] {
	break
      }
      if {$line < $loc_line} {
	foreach {name line} [lookup_line $twin [winfo height $twin]] {
	  break
	}
	if {$line > $loc_line} {
	  set not_visible 0
	}
      }
    }
  } else {
    debug "gdb_loc returned $loc_info"
  }

  if {$not_visible} {
    set y [expr int([winfo height $twin] / 2)]
    foreach {name line addr type} [lookup_line $twin $y] {
      break
    }
    switch $type {
      src {
	return [gdb_loc $name:$addr]
      }
      asm {
	return [gdb_loc *$addr]
      }
    }
  } else {
    return $loc_info
  }
}

# ------------------------------------------------------------------
#  METHOD:  lookup_line - translated win & y position line info
#
#    If win is {}, or y is -1, then the saved values from the popup
#    array are used.
#
#  Return:
#    name - the fileName
#    line - the line number in the text widget
#    addr - the source line number, if in source mode, the
#           address if in assembly mode, and if in mixed mode,
#           the line if it is a source line, or the address if it
#           is an assembly line
#    type - src if it is a source line, asm if an assembly line.
#   set_cmd - for convenience, this is the command needed to set a 
#             breakpoint at this address.
# ------------------------------------------------------------------
body SrcTextWin::lookup_line {win y} {
  #debug "$win $y"
  if {$y == -1} {
    set y $popups(saved_y)
  }

  if {$win == {}} {
    set win $popups(saved_win)
  }

  scan [$win index @0,$y] "%d." line
  set name [lindex [::file split $current(filename)] end]

  # If we are in the SOURCE window (either because the mode is SOURCE,
  # or SRC+ASM, and we are in the upper pane, then return the 
  if {([string compare $current(mode) SOURCE] == 0)
      || ([string compare $current(mode) SRC+ASM] == 0 
	  && [string compare $win $twin] == 0)} {
    set addr $line
    set type "src"
  } else {
    if {[info exists _map($Cname,line=$line)]} {
      set addr $_map($Cname,line=$line)
      set type "asm"
    } else { 
      # This is a source line in MIXED mode
      set line_contents [$win get $line.0 "$line.0 lineend"]
      #debug "Looking at line: $line contents: \"$line_contents\""
      regexp "^\t(\[0-9\]*)" $line_contents match srcline
      set addr $srcline
      set type "src"
    }
  }

  switch $type {
    asm {
      set set_cmd [list gdb_set_bp_addr $addr]
    }
    src {
      set set_cmd [list gdb_set_bp $current(filename) $addr]
    }
  }

  #debug "Lookup line returning [list $name $line $addr $type $set_cmd]"
  return [list $name $line $addr $type $set_cmd]
}

# ------------------------------------------------------------------
#  METHOD:  continue_to_here - Advance to the line pointed to by the
#  y coordinate in the window win.  If win is {} or y is -1, the values
#  saved in the popups array are used.  
#
#  The threads parameter is not currently used.
# ------------------------------------------------------------------
body SrcTextWin::continue_to_here {{win {}} {y -1} {threads -1}} {
  
  # Look up the line...  This foreach is an lassign...
  foreach {name line addr type set_cmd} [lookup_line $win $y] {
    break
  }

  set dont_change_appearance 1
  foreach i [gdb_get_breakpoint_list] {
    set enabled($i) [lindex [gdb_get_breakpoint_info $i] 5]
  }	    
  gdb_cmd "disable"
  eval $set_cmd temp $threads
  gdb_immediate "continue"
  gdb_cmd "enable"
  foreach i [gdb_get_breakpoint_list] {
    if {![info exists enabled($i)]} {
      gdb_cmd "delete $i"
    } elseif {!$enabled($i)} {
      gdb_cmd "disable $i"
    }
  }
  set dont_change_appearance 0
}

# ------------------------------------------------------------------
#  METHOD:  set_bp_at_line - called when an empty break tag is clicked on
#
# When "threads" is set it means to set a bp on each thread in the list.
# ------------------------------------------------------------------
body SrcTextWin::set_bp_at_line {{type N} {win {}} {y -1} {threads "-1"}} {
  debug "$win $y $type $current(filename) Tracing=$Tracing"
  if {$Running} {return}
  
  # Look up the line...  This foreach is an lassign...

  foreach {name line addr addr_type set_cmd} [lookup_line $win $y] {
    break
  }

  foreach th $threads {    
    switch $type {
      N {
	if {[catch {eval $set_cmd normal $th} msg]} {
	  dbug W $msg
	}
      }
      T {
	if {[catch {eval $set_cmd temp $th} msg]} {
	  dbug W $msg
	}
      }
    }    
  }
}

# ------------------------------------------------------------------
#  METHOD:  remove_bp_at_line - called when a bp tag is clicked on
#
# when "threads" is set it means to set a bp on each thread in the list.
# ------------------------------------------------------------------
body SrcTextWin::remove_bp_at_line {{win {}} {y -1}} {
  
  if {$Running} {return}
  
  # Look up the line...  This foreach is an lassign...
  
  foreach {name line addr type} [lookup_line $win $y] {
    break
  }
  
  if {[string compare $type src] == 0} {
    gdb_cmd "clear $name:$addr"
  } else {
    gdb_cmd "clear *$addr"
  }
}


# ------------------------------------------------------------------
#  METHOD:  set_tp_at_line - called when an empty break region tag is clicked on
#
# when "threads" is set it means to set a bp on each thread in the list.
# ------------------------------------------------------------------
body SrcTextWin::set_tp_at_line {{win {}} {y -1}} {
  debug "$win $y $current(filename) Tracing=$Tracing"

  if {$Running} {return}
  
  # Look up the line...  This foreach is an lassign...
  
  foreach {name line addr type} [lookup_line $win $y] {
    break
  }
  
  switch $type {
    src {
      after idle [list ManagedWin::open TraceDlg -File $name -Lines $addr]
    }
    asm {
      after idle [list ManagedWin::open TraceDlg -File $name -Addresses [list $addr]]
    }
  }
}

# ------------------------------------------------------------------
#  METHOD:  next_hit_at_line - Finds the next trace hit at the line
#           given by win & y...
#
# ------------------------------------------------------------------
body SrcTextWin::next_hit_at_line {{win {}} {y -1}} {
  debug "$win $y $current(filename) Tracing=$Tracing"

  if {!$Browsing} {return}
  
  # Look up the line...  This foreach is an lassign...
  
  foreach {name line addr type} [lookup_line $win $y] {
    break
  }
  
  # If the line and the addr are the same, then the specification was
  # given by line.  Otherwise is was a memory address.

  switch $type {
    src {
      tfind_cmd "tfind line $name:$addr"
    }
    asm {
      tfind_cmd "tfind line *$addr"
    }
  }
  
}

# ------------------------------------------------------------------
#  METHOD:  remove_tp_at_line - called when a tp tag is clicked on
#
# when "threads" is set it means to set a bp on each thread in the list.
# ------------------------------------------------------------------
body SrcTextWin::remove_tp_at_line {{win {}} {y -1}} {
  
  if {$Running} {return}
  
  # Look up the line...  This foreach is an lassign...
  
  foreach {name line addr type} [lookup_line $win $y] {
    break
  }
  switch $type {
    src {
      set tp_num [gdb_tracepoint_exists $name:$addr]
    }
    asm {
      set tp_num [gdb_tracepoint_exists *$addr]
    }
  }
  
  if {$tp_num != -1} {
    if {[catch {gdb_cmd "delete tracepoints $tp_num"} errTxt]} {
      tk_messageBox -type error -message "Could not delete tracepoint number $tp_num
Error was: $errTxt"
    }
  } 

}

# ------------------------------------------------------------------
#  METHOD:  do_tag_popup - The tag bind function for breakpoint popups
# ------------------------------------------------------------------

body SrcTextWin::do_tag_popup {name X Y y} {

  debug "$name $X $Y $y"

  if {$Running || [winfo ismapped $popups($name)]} { 
    return 
  }  

  set popups(saved_y) $y
  set popups(saved_win) [winfo containing -displayof $itk_interior $X $Y] 

  tk_popup $popups($name) $X $Y

}

# ------------------------------------------------------------------
#  METHOD:  do_source_popup - tag bind function for source popups
# ------------------------------------------------------------------

body SrcTextWin::do_source_popup { X Y x y } {
  if {$Running || [winfo ismapped $popups(source)]} { 
    return 
  }  

  # Figure out what window we are over...
  set win [winfo containing -displayof $itk_interior $X $Y]
  debug "$win $X $Y $x $y"

  # Try to get the selection.  If you fail, get the word around the
  # click point.  
  # Note that we don't have to worry about the user clicking over the
  # break area, since the break_rgn_tag will override this...
  
  if {[catch {$win index sel.first} sel_first]} {
    set target_range [$win get "@$x,$y wordstart" "@$x,$y wordend"] 
    set range 0
  } else {
    # If there was a selection, see if it spans multiple lines.
    scan $sel_first "%d.%d" sel_start_line sel_start_char
    set sel_last [$win index sel.last]
    scan $sel_last "%d.%d" sel_end_line sel_end_char

    if {$sel_start_line == $sel_end_line} {
      set range 0
      set target_range [$win get $sel_first $sel_last]
    } else {
      # If the selection encompasses multiple lines, we only care about
      # the start and ending line numbers
      set range 1
      scan [$twin index sel.first] "%d." range_low
      scan [$twin index sel.last] "%d." range_high
    }
  }
  
  $popups(source) delete 0 end
  
  if {$range && $Tracing} {
    # If the selection spans more than one line, it can't be a variable name...
    # So just insert the tracepoint range item
    $popups(source) add command -label "Set Tracepoint Range" \
      -command "$this tracepoint_range $win $range_low $range_high"
    $popups(source) add separator
  } elseif {!$range} {
    # Get just the variable name with this selection (if any)
    set variable [lindex [getVariable -1 -1 $target_range] 0]
    
    if {$variable != ""} {
      # LAME: check to see if VARIABLE is really a number (constants??)
      set is_var [catch {expr {$variable+1}}]

      if {$is_var} {
	$popups(source) add command -label "Add $variable to Watch" \
	  -command [list $this addToWatch $variable]
	$popups(source) add command -label "Dump Memory at $variable" \
	  -command [list ManagedWin::open MemWin -force -addr_exp $variable]
	$popups(source) add separator
      }
    }
  }

  $popups(source) add command -label "Open Another Source Window" \
    -command {ManagedWin::open SrcWin -force}
  if {[info exists ::enable_external_editor] && $::enable_external_editor} {
    $popups(source) add command -label "Open Source in external editor" \
      -command [list $parent edit]
  }
  
  tk_popup $popups(source) $X $Y 
}

# ------------------------------------------------------------------
# METHOD:  addToWatch - add a variable to the watch window
# ------------------------------------------------------------------
body SrcTextWin::addToWatch {var} {
  [ManagedWin::open WatchWin] add $var
}

# ------------------------------------------------------------------
#  METHOD:  do_key  -- wrapper for all key bindings
# ------------------------------------------------------------------
body SrcTextWin::do_key {key} {    
  if {!$Running} {
    switch $key {
      print        { print }
      download     { Download::download_it }
      run          { $parent inferior run }
      stack        { ManagedWin::open StackWin }
      registers    { ManagedWin::open RegWin }
      memory       { ManagedWin::open MemWin }
      watch        { ManagedWin::open WatchWin }
      locals       { ManagedWin::open LocalsWin }
      breakpoints  { ManagedWin::open BpWin }
      console      { ManagedWin::open Console }
      step         { $parent inferior step }
      next         { $parent inferior next }
      finish       { $parent inferior finish }
      continue     { $parent inferior continue }
      stepi        { $parent inferior stepi }
      nexti        { $parent inferior nexti }
      up           { catch {gdb_cmd up} }
      down         { catch {gdb_cmd down} }
      quit         { gdbtk_quit }
      tdump        { ManagedWin::open TdumpWin }
      tracepoints  { ManagedWin::open BpWin -tracepoints 1}
      tfind_next   { catch {gdb_immediate tfind} }
      tfind_prev   { catch {gdb_immediate "tfind -"} }
      tfind_start  { catch {gdb_immediate "tfind start"} }
      tfind_line   { catch {gdb_immediate "tfind line"} }
      tfind_tp     { catch {gdb_immediate "tfind tracepoint"} }
      open         { catch {_open_file} }
      browser      { catch {ManagedWin::open BrowserWin} }
      thread_list  { catch {ManagedWin::open ProcessWin} }
      debug	     { catch {ManagedWin::open DebugWin} }
      default      {
	#start-sanitize-kod
	# FIXME: after sanitization is out kod must be
	#        treated as all other keys (above)
	if {$key == "kod"} {
	  ManagedWin::open KodWin
	} else {
	  #end-sanitize-kod
	  dbug E "Unknown key binding: \"$key\""
	  #start-sanitize-kod
	}
	#end-sanitize-kod
      }
    }
  } else {
    debug "ignoring keypress -- running"
  }
}

# ------------------------------------------------------------------
#  METHOD:  mode_get - get the source mode
# ------------------------------------------------------------------
body SrcTextWin::mode_get {} {
  return $current(mode)
}

# ------------------------------------------------------------------
#  METHOD:  mode_set - change the source mode
# ------------------------------------------------------------------
body SrcTextWin::mode_set {new_mode {go 1}} {
  debug "$new_mode"

  if {$new_mode != $current(mode)} {

    if {$current(mode) == "SRC+ASM"} {
      if {$_bpane != ""} {$itk_interior.p hide $_bpane}
      set _bpane ""
      set _bwin ""
    }
    
    set current(mode) $new_mode
    set mode_changed 1

    if {$go} {
      location $current(tag) $current(filename) $current(funcname) \
	$current(line) $current(addr) $pc(addr) $current(lib)
    }
  }
}

# ------------------------------------------------------------------
# METHOD:  cancelMotion - cancel any pending motion callbacks for
#          the source window's variable balloons
# ------------------------------------------------------------------
body SrcTextWin::cancelMotion {} {
  catch {after cancel $timeoutID}
}

# ------------------------------------------------------------------
# METHOD:  motion - callback for mouse motion within the source
#          window's text widget
# ------------------------------------------------------------------
body SrcTextWin::motion {type win x y} {
  global gdb_running
  cancelMotion

  if {$type == "var"} {
    # Only show variables if we are running
    if {$gdb_running} {	
      set timeoutID [after $TimeOut "$this showBalloon $win $x $y"]
    }
  } else {
    set timeoutID [after $TimeOut "$this showBPBalloon $win $x $y"]
  }
}


# ------------------------------------------------------------------
# METHOD:  showBPBalloon - show BP information in a balloon
# ------------------------------------------------------------------
body SrcTextWin::showBPBalloon {win x y} {
  if {$Running} { return }
  $win tag remove _show_variable 1.0 end 
  set line [lindex [split [$win index @0,$y] .] 0]
  set bps ""

  switch $current(mode) {
    SRC+ASM {
      if {$win == $bwin} {
	if {[info exists _map($Cname,line=$line)]} {
	  set addr $_map($Cname,line=$line)
	  set bps [gdb_find_bp_at_addr $addr]
	} else {
	  return
	}
      }
    }
    ASSEMBLY {
      if {[info exists _map($Cname,line=$line)]} {
	set addr $_map($Cname,line=$line)
	set bps [gdb_find_bp_at_addr $addr]
      } else {
	return
      }
    }
    MIXED {
      if {[info exists _map($Cname,line=$line)]} {
	set addr $_map($Cname,line=$line)
	set bps [gdb_find_bp_at_addr $addr]
      } else {
	return
      }
    }
  }

  if {$bps == ""} {
    set bps [gdb_find_bp_at_line $current(filename) $line]
  }

  set str ""
  set need_lf 0
  foreach b $bps {
    set bpinfo [gdb_get_breakpoint_info $b]
    lassign $bpinfo file func linenum addr type enabled disposition \
      ignore_count commands cond thread hit_count
    if {$thread == "-1"} {set thread "all"}
    set file [lindex [file split $file] end]
    if {$enabled} {
      set enabled "ENA"
    } else {
      set enabled "DIS"
    }
    if {$cond == ""} {set cond "none"}
    if {$need_lf} {
      append str \n
    } else {
      set need_lf 1
    }
    append str [format "breakpoint %d at %s:%d (%#x)\n\t%s %s %s %s %s" \
		  $b $file $linenum $addr $enabled $type $disposition \
		  threads=$thread cond=$cond]
  }

  # Scope out which break type is set here, and use the tag to get
  # the break region range...

  set tag_list [$win tag names $line.0]
  set break_tag [lindex $tag_list [lsearch -glob $tag_list *bp_tag]]
  set end [lindex [$win tag nextrange $break_tag $line.0 $line.end] 1]

  if {$end != ""} {
    $win tag add _show_variable $line.0 $end
    balloon register $win $str _show_variable
    balloon show $win _show_variable 1
  }
}

# ------------------------------------------------------------------
# METHOD:  showBalloon - (possibly) show a variable's value in
#          a balloon-help widget
# ------------------------------------------------------------------
body SrcTextWin::showBalloon {win x y} {
  if {$Running} { return }
  $twin tag remove _show_variable 1.0 end 
  catch {tmp delete}

  set variable [getVariable $x $y]
  if {[llength $variable] != 3} {
    return
  }    
  
  # We get the variable name, and its start and stop indices in the text 
  # widget, so all we need to do is set the tag and register the balloon help
  set varName [lindex $variable 0]
  set start   [lindex $variable 1]
  set stop    [lindex $variable 2]

  # Get the address associated with this line
  foreach {file text_line source_line type} [lookup_line $twin $y] {
    break
  }
  if {$type == "src"} {
    set linespec [gdb_loc $file:$source_line]
    set var_pc [lindex $linespec 4]
  } else {
    set var_pc $source_line
  }

  # Create the variable object
  catch {$_balloon_var delete}
  set err [catch {gdb_variable create -expr $varName -pc $var_pc} _balloon_var]
  if {!$err} {
    set value [balloon_value $_balloon_var]
    if {$value != ""} {
      $win tag add _show_variable $start $stop

      # display variable's value
      balloon register $twin "$varName=$value" _show_variable
      balloon show $win _show_variable
    } else {
      # No value/error. Don't show it.
      catch {$_balloon_var delete}
      set _balloon_var {}
    }
  } else {
    set _balloon_var {}
  }
}

# ------------------------------------------------------------------
# METHOD:  getVariable - get the name of the 'variable' under the
#          mouse pointer in the text widget
# ------------------------------------------------------------------
body SrcTextWin::getVariable {x y {line {}}} {
  #debug "$x $y $line"
  if {$x != -1 && $y != -1} {
    # Since we will only be concerned with this line, get it
    set line [$twin get @${x},${y}linestart @${x},${y}lineend]
    #debug "new line=$line"
    set simple 0
  } else {
    # This is not quite right -- still want constants to appear...
    set simple 1
  }

  # The index into LINE that contains the char at which the pointer hangs
  set a [split [$twin index @$x,$y] .]
  set lineNo [lindex $a 0]
  set index  [lindex $a 1]
  set s [string range $line $index end]
  set last {}
  foreach char [split $s {}] {
    if {[regexp -- {([^a-zA-Z0-9_>.-])} $char dummy]} {
      break
    }
    lappend last $char
  }
  set last [string trimright [join $last {}] ->]

  # Decrement index for string -- will need to increment it later
  incr index -1
  set tmp [string range $line 0 $index]
  set s {}
  foreach char [split $tmp {}] {
    set s [linsert $s 0 $char]
  }

  set first {}
  foreach char $s {
    if {[regexp -- {([^a-zA-Z0-9_>.-])} $char dummy]} {
      break
    }
    set first [linsert $first 0 $char]
  }
  #set first [string trimleft [join $first {}] ->]
  set first [join $first {}]
  #debug "FIRST=$first\nLAST=$last"

  # Validate the variable
  set variable [string trim $first$last \ ]
  if {!$simple && ![regexp {^[a-zA-Z_]} $variable dummy]} {
    #debug "Rejecting: $variable"
    return {}
  }

  incr index
  # Find the boundaries of this word in the text box
  set a [string length $first]
  set b [string length $last]

  # Gag! If there is a breakpoint at a line, this is off by one!
  if {[hasBP $twin $lineNo] || [hasTP $twin $lineNo]} {
    incr a -1
    incr b 1
  }
  set start "$lineNo.[expr {$index - $a}]"
  set end   "$lineNo.[expr {$index + $b}]"
  return [list $variable $start $end]
}

# ------------------------------------------------------------------
#  METHOD:  trace_help - update statusbar with ballon help message
# ------------------------------------------------------------------
body SrcTextWin::trace_help {args} {
  upvar #0 ${this}_balloon a
  if {$a == ""} {
    $parent set_status
  } else {
    $parent set_status $a 1
  }
}

body SrcTextWin::line_is_executable {win line} {
  # there should be an image or a "-" on the line
  set res [catch {$win image cget $line.0 -image}]
  if {!$res || [$win get $line.0] == "-"} {
    return 1
  }
  return 0
}

# ------------------------------------------------------------------
# METHOD:   tracepoint_range - create tracepoints at every line in
#           a range of lines on the screen
# ------------------------------------------------------------------
body SrcTextWin::tracepoint_range {win low high} {
  debug "$win $low $high"

  switch $current(mode) {
    SOURCE {
      set lines {}
      for {set i $low} {$i <= $high} {incr i} {
	if {[line_is_executable $win $i]} {
	  lappend lines $i
	}
      }
    }

    ASSEMBLY {
      set addrs {}
      for {set i $low} {$i <= $high} {incr i} {
	lappend addrs $_map($Cname,line=$i)
      }
    }

    MIXED {
      set addrs {}
      for {set i $low} {$i <= $high} {incr i} {
	if {[line_is_executable $win $i]} {
	  lappend addrs $_map($Cname,line=$i)
	}
      }
    }

    SRC+ASM {
      if {$win == $awin} {
	# Assembly
	set addrs {}
	for {set i $low} {$i <= $high} {incr i} {
	  lappend addrs $_map($Cname,line=$i)
	}
      } else {
	# Source
	set lines {}
	for {set i $low} {$i <= $high} {incr i} {
	  if {[line_is_executable $win $i]} {
	    lappend lines $i
	  }
	}
      }
    }
  }
  
  if {[info exists lines]} {
    debug "Got executible lines: $lines"
    if {[llength $lines]} {
      set name [::file tail $current(filename)]
      ManagedWin::open TraceDlg -File $name -Lines $lines
    }
  } elseif {[info exists addrs]} {
    debug "Got executible addresses: $addrs"
    if {[llength $addrs]} {
      set name [::file tail $current(filename)]
      ManagedWin::open TraceDlg -File $name -Addresses $addrs
    }
  } else {
    debug "Got no executible lines in the selected range..."
  }

  # Clear the selection -- it looks a lot better.
  $twin tag remove sel 1.0 end
}


# ------------------------------------------------------------------
#  METHOD:  search - search for text or jump to a specific line
#           in source window, going in the specified DIRECTION.
# ------------------------------------------------------------------
body SrcTextWin::search {exp direction} {
  if {$exp != ""} {
    set result {}
    if {[regexp {^@([0-9]+)} $exp dummy index]} {
      append index .0
      set end [$twin index "$index lineend"]
    } else {
      set index [$twin search -exact -count len -$direction -- $exp $SearchIndex]
      
      if {$index != ""} {
	set end [split $index .]
	set line [lindex $end 0]
	set char [lindex $end 1]
	set char [expr {$char + $len}]
	set end $line.$char
	set result "Match of \"$exp\" found on line $line"
	if {$direction == "forwards"} {
	  set SearchIndex $end
	} else {
	  set SearchIndex $index
	}
      }
    }
    if {$index != ""} {
      # Highlight word and save index
      $twin tag remove search 1.0 end
      $twin tag add search $index $end
      $twin see $index
    } else {
      set result "No match for \"$exp\" found"
    }
    return $result
  } else {
    $twin tag remove search 1.0 end
  }
}

# -----------------------------------------------------------------------------
# NAME:		SrcTextWin::LoadFromCache
#
# SYNOPSIS:	LoadFromCache {w name asm lib}
#
# DESC:		Looks up $name in the cache.  If $name is cached, replace the
#		pane $w with the cached pane. Otherwise create a new
#		pane and scrolledtext widget and set _${w}pane and _${w}win.
#
# ARGS:		w	"t" or "b" (for Top and Bottom pane)
#		name	name to look for in cache. This will be a filename if
#			we are filling in a source window, or an address 
#			otherwise.
#		asm	'A' for assembly mode, 'M' for mixed mode.
#		lib	library name
#
# RETURNS:	0 - read from cache
#		1 - created new (blank) widget
#
# NOTES:	If you call this and a new widget is created which cannot be
#		filled in later due to errors, call UnLoadFromCache.
# -----------------------------------------------------------------------------
body SrcTextWin::LoadFromCache {w name asm lib} {
  debug "$w $name $asm"
  upvar ${w}win win
  upvar _${w}pane pane

  append name "," $asm "," $lib

  set oldpane $pane
  if {[info exists Stwc($name)]} {
    debug "READING CACHE $name->$Stwc($name)"
    set pane $Stwc($name)
    if {$oldpane != ""} {
      $itk_interior.p replace $oldpane $pane
    } else {
      $itk_interior.p show $pane
    }
    set win [[$itk_interior.p childsite $pane].st component text]
    if {$asm != ""} {
      set Cname $name
    }
    set res 0
  } else {
    set Stwc($name) pane$filenum
    incr filenum

    set pane $Stwc($name)
    debug "pane=$pane"
    if {$oldpane != ""} {$itk_interior.p hide $oldpane}
    $itk_interior.p add $pane
    set p [$itk_interior.p childsite $pane]
    set st [iwidgets::scrolledtext $p.st \
	      -hscrollmode dynamic -vscrollmode dynamic]
    set win [$st component text]

    if {$asm != ""} {
      set Cname $name
    }
    pack $st -expand yes -fill both
    set res 1
  }

  # reconfigure in case some preferences have changed
  config_win $win $asm
  return $res
}

# ------------------------------------------------------------------
#  METHOD:  UnLoadFromCache - revert back to previously cached widget
#  This is used when a new widget is created with LoadFromCache but
#  there is a problem with filling the widget.  
# ------------------------------------------------------------------

body SrcTextWin::UnLoadFromCache {w oldpane name asm lib} {
  debug "$w $oldpane $name"
  upvar ${w}win win
  upvar _${w}pane pane
  debug "pane=$pane win=$win"

  append name "," $asm "," $lib
  $itk_interior.p delete $pane
  unset Stwc($name)
  $itk_interior.p show $oldpane
  set pane $oldpane
  set win [[$itk_interior.p childsite $pane].st component text]
}

# ------------------------------------------------------------------
#  METHOD:  print - print the contents of the text widget
# ------------------------------------------------------------------
body SrcTextWin::print {top} {
  # FIXME
  send_printer -ascii [$twin get 1.0 end] -parent $top
}

# ------------------------------------------------------------------
#  METHOD:  ask_thread_bp - prompt for thread(s) for BP
# ------------------------------------------------------------------
body SrcTextWin::ask_thread_bp {} {
  debug
  gdbtk_busy
  if {[catch {gdb_cmd "info thread"} threads]} {
    # failed. Just leave
    gdbtk_idle
    return
  }
  set threads [split $threads \n]

  if {[llength $threads] == 0} {
    show_warning "No threads were found.\nYou may only set breakpoints on threads\nthat have already been created."
    return
  }
  
  set a [toplevel .[gensym]]
  wm title $a "Thread Selection"
  CygScrolledListbox $a.slb -selectmode multiple
  
  set width 0

  # Have to be a bit careful here.  There may be extra thread info, so we 
  # first need to find out the real thread info lines, and then put
  # only those into the listbox.

  catch {unset id}

  set num_threads 0
  foreach line $threads {
    # Active line starts with "*"
    if {[string index $line 0] == "*"} {
      # strip off leading "*"
      set line " [string trimleft $line "*"]"
    }
    # scan for GDB ID number at start of line
    # FIXME - this is currently pretty weak, since if the extra thread
    # info starts with a number, this will fail.  Really should write
    # a C-command to give us parseable thread info.
    if {[scan $line "%d" id($num_threads)] == } {
      debug "Putting thread line no $num_threads at $id($num_threads) - $line"
      lappend real_threads $line
      if {[string length $line] > $width} {
	set width [string length $line]
      }
      incr num_threads
    }
  }

  # info threads reports the threads in reverse order.  Switch them.

  foreach line $real_threads {
    $a.slb.list insert 0 $line
  }
  
  # Also reverse the ID List...

  set half_way [expr $num_threads/2]

  for {set i 0} {$i < $half_way} {incr i} {
    set other [expr $num_threads - $i - 1]
    set tmp  $id($i)
    set id($i) $id($other)
    set id($other) $tmp
  }

  $a.slb.list configure -width $width -height $num_threads

  frame $a.b
  button $a.b.ok -text OK -underline 0 -width 7 \
    -command "$this do_thread_bp $a.slb.list"
  button $a.b.cancel -text Cancel -width 7 -underline 0 -command "destroy $a"
  pack $a.b.ok $a.b.cancel -side left
  standard_button_box $a.b
  pack $a.b -fill x -expand yes -side bottom -padx 5 -pady 5
  pack $a.slb -side top -fill both -expand yes
  bind $a.b.ok <Return> "$a.b.ok flash; $a.b.ok invoke"
  focus $a.b.ok
  gdbtk_idle

}

# ------------------------------------------------------------------
#  METHOD:  do_thread_bp - callback from thread selection
# ------------------------------------------------------------------
body SrcTextWin::do_thread_bp {listbox} {
  debug "$listbox [$listbox curselection]"
  set x ""
  foreach i [$listbox curselection] {
    lappend x $id($i)
  }
  $this set_bp_at_line N {} -1 $x
  destroy [winfo toplevel $listbox]
}


# public method for testing use only!
body SrcTextWin::test_get {var} {
  return [set $var]
}
